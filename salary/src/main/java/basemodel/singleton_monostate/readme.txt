有一些类只有一个实例，实例大多时候在程序启动时创建出来，并且只有程序结束时才能删除；
        有时对象是应用程序的基础对象，通过这些基础对象可以得系统中许多其他对象；
        有时是工厂对象，用来创建系统中其他对象；
        有时是管理器对象，负责管理某些其他对象并以其他方式控制他们

        若果对象创建了了多份，就是严重的逻辑错误。如果创建了多份基础对象那个，那么对应用程序中对象的访问就依赖于
        所选择的那个基础对象

Singleton单例模式：
         好处：
                1.跨平台，使用合适的中间件（例如RMI），可以把singleton模式扩展为跨多个JVM和多个计算机工作
                2.适用于任何类，只需把一个类的构造函数变成私有的，并且在其中添加相应的静态函数和变量，就可以使类变成单例
                3.可以通过派生创建，给定一个类，可以创建他的一个Singleton子类
                4.延迟求值，如果单例始终没用，就不会创建它

         代价：
                1.摧毁方法未定义
                2.不能继承
                3.效率问题
                4.不透明性

         运用Singleton模式：



Monostate状态模式：
        完全不同于单例模式的工作机制
        好处：
            1.透明性
            2.可派生性
            3.多态性

         代价：
             1.不可转换性
             2.效率问题
             3.内存占用---即使从未使用过，变量也要占据内存空间
             4.平台局限性



不同之处：
        1.Singleton关注结构，Monostate关注行为，Singleton模式强制结构上的单一性，防止它创建多个实例对象，
          Monostate模式强制行为上的单一性，而没有强加结构方面的限制。